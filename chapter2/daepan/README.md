# 실행 컨텍스트

실행 컨텍스트는 **실행 할 코드에 제공할 환경 정보들을 모아 놓은 객체**이고, 자바스크립트의 동적 언어로서의 성격을 가장 파악할 수 있는 개념이다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고, 외부 환경정보를 구성하고, this값을 설정한는 등의 동작을 수행한다.
우의 특성등로 인해 다른 언어와는 다른 특이한 현상이 발생하게 된다.

실행 컨텍스트는 자바스크립트의 가장 중요한 핵심 개념이다.
사실 클로저를 지원하는 대부분의 언어에서 유사 혹은 동일한 개념이 적용된다.
실행 컨텍스트를 이해하는 JS 개발자로써의 성장을 고무할 것이다.

## 실행 컨텍스트란?

이를 이해하기 위한 선행 지식으로는 스택과 큐가 있다.
가볍게 개념 정리하고 넘어간다.

1.  스택
    데이터를 후입선출 구조로 유지하는 추상 데이터형

    - 특징
      입력과 출력이 하나의 방향으로 이루어져 있다.
      LIFO(Last In First Out)방식, 나중에 넣은 것이 먼저 나온다. 후입 선출
      중간에서의 데이터 삭제가 불가능하다.

    - Push, Pop
      push: 스택에 요소를 삽입하는 연산
      pop: 스택에 요소를 삭제하는 연산

![](https://lh6.googleusercontent.com/Qsgy6PxroInioTNUjndr227eeKedkWzJYGu6h8z4b7iG8WlxNRilTRVRi5PZWLzQ5fwH0GEboWTPrqRxhC48IDN11GbLTjAYBoYS3OgvmknqIuHqoRLOZhbf1-anyLR8bWN2RnxU)

    - StackOverFlow
     만약 스택이 꽉 찬 상태에서 데이터를 더 넣을경우 일어난다.
     왜냐하면 스택은 크기를 고정해서 사용하기에
     고정된 크기의 스택에 데이터를 계속넣어 넘치게 되면 다른 메모리 영역을 침범하게 된다.

2.  큐
    - 특징
      FIFO 선입선출, 먼저 넣은 데이터가 먼저 나오는 형태
      큐 처음 위치와 마지막 위치만 기억한다.

다시 실행 컨텍스트로 돌아가보자. 실행컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.
동일한 호나경에 있는 코드들을 실행할 떄 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아 올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는 방식으로 전체 코드의 환경과 순서를 보장한다. 여기서 동일한 환경이란? 즉, 하나의 실행 컨텍스트를 구성할수 있는 방법으로 전역공간, eval()함수, 함수등이 있다.//실행 컨텍스트를 나누는 기준

주로 사용하는 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것이다. 좀 더 알아보자

콜스택에 실행 컨텍스트가 어떤 순서로 쌓이고 어떤 순서로 코드실행에 관여하는지만 확인해보자

```
	var a = 1;
	function outer(){
		function inner(){
			console.log(a)
			var a = 3;
		}
		inner();
		console.log(a)
	}
	outer();
	consol.log(a)
```

1.  코드가 실행되는 순간 전역 컨텍스트가 콜스택에 담긴다.(실행시 활성화)
2.  outer 함수를 호출하면 자바스크립트 엔진은 outer와 관련된 환경정보를 수집하고 실행컨텍스트를 생성하여 콜스택에 담는다.
3.  콜스택 맨 위에는 outer가 있으므로 전역컨텍스트의 과정은 멈추고 outer 함수 내부의 코드들을 순차적으로 실행한다.
4.  outer 함수 내부의 inner함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기며 outer컨텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행한다.
5.  inner 함수 내부에서 a변수에 3을 할당. inner함수 종료되면 콜스택에서 제거한다.
6.  outer 컨텍스트가 콜스택에 맨위에 올라오고 outer 실행이 종료되고 실행 컨텍스트가 콜스택에 제거
7.  전역컨텍스트가 콜스택에 남게된다. a변수의 값을 출력하면 전역 컨텍스트도 제거되고 콜 스택에 아무것도 남지 않은 상태로 종료된다.

스택 구조를 잘 생각해보면 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순가이 곧 현재 실행하는 코드에 관여하게 되는 시점임을 알 수 있다. 기존의 컨텍스트는 새로 쌓인 컨텍스트보다 아래에 위치할 수 밖에 없기 때문이다.
이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경정보들을 수집해서 실행 컨텍스트 객체에 저장한다.
(이 객체는 자바스크립트 엔진이 활용할 목적으로 생성된 것-개발자가 코드 확인 불가!)
컨텍스트에 담기는 정보들을 보면

- VariableEnviroment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보 선언 시점의 LE의 ([스냅샷](https://itstorageaws.tistory.com/12))으로 변경, 변경사항은 반영하지 않음
- LexicalEnviroment: 처음에는 VariableEnviroment와 같지만 변경 사항이 실시간으로 반영된다.
- ThisBinding : this 식별자가 바라봐야할 객체 대상
  등이 있다.

이 3가지 요소에 대해 자세히 알아보자.

## VariableEnviroment

VariableEnviroment에 담기는 내용은 LexicalEnviroment같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다.
실행 컨텍스트를 생성할 때 VariablEnviroment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnviroment를 만들고 이후에는 LexicalEnviroment를 주로 활용하게 된다.
VariableEnviroment와 LexicalEnviroment의 내부는 enviromentRecord와 outer-EnviromentRefrence로 구성되어있다. 초기화 과정 중에는 사실상 완전히 동일하고 이후 코드 지행에 따라 서로 달라지게 될 것이다.

## LexicalEnviroment

LexicalEnviroment는 어휘적환경, 정적환경이라는 단어로 많이 사용하지만 의미적으로 어울리지 않아 정적이라는 말은 수시로 변하는 환경 정보를 의미하는 LexicalEnviroment와는 어울리지 않다.
책에서는 사전적인이라는 표현을 통해 해석하지만 이는 개인의 이해를 위한 용어이지 절대 이거라고 이해하지말자. 단순 언어 그자체로 받아들이는 편이 좋을 것 같다.

### enviromentRecord와 호이스팅

enviromentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언되 변수의 식별자들이 식별자에 해당한다. 컨텍스트 내부 전체를 처음부터 끝까지 확인하며 순서대로 수집한다.

변수 정보를 수집하는 과정을 모두 마쳤어도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다. 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있는 것이다. 그렇다면 JS엔진의 실제 코드를 실행한다 라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없을 것이다. 여기서 호이스팅이라는 개념이 등장하게 된 것이다.
변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 끌어올린 것으로 간주하자는 것이다.

호이스팅 규칙
enviromentRecord에는 매개변수의 이름, 함수 선언 변수명들이 담긴다.
몇 가지 예제를 통해 알아보자

1. 매개변수와 변수에 대한 호이스팅

```
	function a(x){//매개변수
		console.log(x);
		var x;//변수 선언
		console.log(x);
		var x=2;//변수 선언
		console.log(x);
	}
```

위와 같이 함수를 호출한 경우에 결과에 대해 LexicalEnviroment의 입장에서는 인자를 함수 내부의 어떤 코드 보다 선언 및 할당이 이뤄진 것으로 간주할 수 있기에 코드를 조금 바꿔보겠다.

2. 매개변수와 변수에 대한 호이스팅 - 매개변수를 변수 선언/할당과 같다고 간주한 변환상태

```
	function a(){
		var x=1;//매개변수
		console.log(x);
		var x;//변수 선언
		console.log(x);
		var x=2;//변수 선언
		console.log(x);
	}
```

이 상태에서 변수 정보를 수집하는 호이스팅을 처리해보자
enviromentRecord는 현재 실행될 컨텍스트의 대상 코드내에 어떤 식별자들이 있는지만을 수집한다.
따라서 변수를 호이스팅 할때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다.
매개 변수의 경우도 마찬가지이다.
호이스팅을 한 결과에 대한 코드를 예제로 확인해보자(실제로 이렇게 변하는 것은 아니니 주의!)

```
	function a(){
		var x;
		var x;
		var x;

		x=1;
		console.log(x);//1
		console.log(x);//1
		x=2;
		console.log(x);//2
	}
```

함수 선언을 추가한 예제를 하나 더 살펴보자

```
	function a(){
		console.log(b);
		var b='bbb';
		console.log(b);
		function b(){}
		console.log(b);
	}
```

출력 예상 : undefined, 'bbb', 'bbb'
a함수를 실행하는 순가 a함수의 실행컨텍스트 생성
변수명과 함수선언 정보 위로 끌어올림
변수는 선언부와 할당부로 분하지만 함수의 경우에는 함수 전체를 끌어올림

예상 변환

```
	function a(){
		var b='bbb';
		function b(){}

		console.log(b);
		b='bbb'
		console.log(b);
		console.log(b);
	}
```

실제 결과 : b함수 , 'bbb' , 'bbb'

### 함수 선언문과 함수 표현식

호이스팅을 다루면서 알아두면 좋은 내용!
둘 모두 함수를 새롭게 정의할 때 쓰이는 방식이다 그 중 함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, 반대로 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것을 말한다.
함수 선언문의 경우 반드시 함수명이 정의돼있어야하는 반면, 함수 표현식은 없어도 된다.
함수명을 정의한 함수 표현식 : 기명 함수 표현식
함수명을 정의하지 않은 함수 표현식 : 익명 함수 표현식
일반적으로 함수표현식은 익명 함수 표현식을 말하기도 한다.

```
	function a(){}//함수 선언문 a가 변수명
	a();

	var b = function (){}//익명함수표현식 b가 곧 함수명
	b();

	const c = function d(){}//기명함수표현식 변수명은 c, 함수명은 d
	c();
	d();
```

예제를 통해 함수 선언문과 함수 표현식의 실질적인 차이를 보자

```
	console.log(sum(1,2));
	console.log(multiply(3,4));

	function sum(a,b){ //함수선언문 sum
	return a+b;
	}
	var multiply=function(a,b){//함수 표현식 multiply
		return a+b;
	}
```

실행 컨텍스트의 LexicalEnviroment는 두 가지 정보를 수집하는데, 그 중에 enviromentRecord의 정보 수집 과정에서 발생하는 호이스팅을 보자.

```
	function sum(a,b){ //함수선언문 sum
		return a+b;
	}
	var multiply;

	console.log(sum(1,2));
	console.log(multiply(3,4));


	multiply=function(a,b){//함수할당부
		return a+b;
	}
```

함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅 해준다. 함수에 대한 할당도 여기서 함수 선언문과 함수 표현식의 극적인 차이가 발생한다.

sum함수는 선언전에는 호출해도 아무 문제 없이 실행된다. 어떻게 작성해도 오류를 내지 않는다는 것에서 초급자들이 자바스크립트를 좀 더 쉽게 접근할 수 있게 해주는 측면도 있으나, 반대로 큰 혼란을 일으키는 원인이 되기도 한다. 우리는 글을 위에서 아래로, 좌에서 우로 읽는 문화에서 살아왔기에 아래에서 선언한 것이 위에서 문제 없이 실행되는 것을 받아들이기 어려울 수 있습니다. 설령 이해하더라도 어색함과 거부감을 느끼기 쉬운 상황이다. 프로그래밍 언어도 인간이 만든 것이니만큼 '선언한 후에야 호출할 수 있다' 라는 편이 훨씬 자연스러울 것이다.

함수 선언문이 혼란스러운 개념이라는 것에 대한 예시를 하나 보여주겠다.
만약 당신이 바쁜 업무 중에 함수 선언을 하다 중복되게 선언하는 경우를 보자

```
	***
	100 function sum(x,y){ return x+ y}
	***
	5000 function sum(x,y){ return x + '+'+y+'='+ (x+y)}
	***
```

만약 이런식으로 별다른 테스트 없이 커밋 머지되어서 배포되었다고 가정해보자
전역 컨텍스트가 활성화 될때 전역 공간에 선언된 함수들이 모두 호이스팅되고
동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌우게 된다.
따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수뿐이다
A가 의도했던 함수는 숫자로 된 결과값을 반환하는 것이었는데 실제로는 전혀 다른 문자열을 반환하게 된다.
정작 위에 있는 함수 sum은 아무런 문제를 일으키지 않고 전혀 다른 함수에서 문제가 발생하게 되는 오류가 출력된다.

만약 sum함수를 함수 표현식으로 정의했다면 어땟을까?

```
	***
	100 var sum = function (x,y){ return x+ y}
	~200 var a = sum(1,2);
	***
	5000 var sum = function (x,y){ return x + '+'+y+'='+ (x+y)}
	~5010 var c = sum(1,2);
	***
```

상대적으로 안전하게 출력된다. 물론 전역 공간에 함수를 선언하거나 동명의 함수를 넣는 것은 치명적이다
하지만 함수가 여럿 존재하는 상황이더라도 모두 함수가 표현식으로 정의돼 있었다면 위와 같은 상황은 예방할 것이다.
