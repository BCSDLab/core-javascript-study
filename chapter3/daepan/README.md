# this

자바스크립트에서 가장 혼란스러운 개념이다.
다른 대부분의 객체지향 언어에서는 this는 클래스를 생성한 인스턴스의 객체를 의미한다.
클래스에서만 사용할 수 있기에 혼란의 여지가 없거나 많지 않았지만, JS의 경우에는 this가 바라보는 대상이 달라지는데 어떤 이유로 그렇게 되었는지 파악하기도 쉽지 않고, 예상과는 전혀 다른 대상을 바라보는 경우도 있다.
이런 경우에 문제를 해결하려면 원인을 추적해서 수정해야하는데 정확한 작동 방식을 이해하지 못하면 원인을 파악해서 해결할 수 없다.
함수와 객체의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.
이번 장에서는this가 어떻게 달라지는지 왜 그렇게 되는ㄴ지 예상과 다른 대상을 바라보고 있을 경우 그 원인을 효과적으로 추적하는 방법등을 살펴보겠다.

## 상황에 따라 달라지는 this

JS 기준, this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말해 **this는 함수를 호출할 때 결정**된다고 할 수 있다.
함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.

### 전역 공간에서의 this

전역공간에서 this는 전역 객체를 가리킨다. 개념상 전역컨텍스트를 생성하는 주체가 바로 전역객체이기 때문이다.
전역객체는 JS런타임 환경에 따라 다른 이름과 정보를 가지고 있다.
브라우저 환경에서 전역객체는 window이고 Node.js환경에서는 global이다.

- 전역공간의 특이한 성질
  전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당한다.
  변수이면서 객체의 프로퍼티이기도 한 것이다.
  자바스크립트의 모든 변수는 특정 객체의 프로퍼티로써 동작하기 때문이다.
  사용자가 변수를 선언하더라도 실제 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로서 인식한다.
  특정 객체란 바로 실행 컨텍스트의 LexicalEnviroment이다.
  실행 컨텍스트는 변수를 수집해서 LE의 프로퍼티로 저장한다. 이후 어떤 변수를 호출하면 LE를 조회하여 일치하는 프로퍼티가 있는 경우 그 값을 반환한다.
  (전역 컨텍스트의 경우, LE는 전역객체를 그대로 참조한다.)

정확히는 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.
변수 a라는 것에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프LE에서 a를 발견하여 도달한다. 전역변수 a에는 그냥 단순하게 window.이 생략된 것이라고 여겨도 괜찮다.

전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우는 삭제의 경우를 들 수 있다.
delete연사자를 사용하는 것이 이상할 수 는 있지만 전역변수가 곧 전역객체의 프로퍼티이므로 문제가 되지 않는다. 다만 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제되지만 반면 전역변수로 선언된 것은 삭제되지 않는다.
이는 이 둘을 나누는 기준이 된다. 과정을 살펴보면 전역변수를 선언하면 JS 엔진이 자동으로 전역객체의 프로퍼티를 할당하면서 추가저긍로 해당 프로퍼티의 configurable속성을 false로 정의한다.
var로 선언한 변수와 전역객체의 프로퍼퍼티는 호이스팅 여부 및 configurable여부에서 차이를 보여준다.

### 메서드로서 호출할 때 그 메서드 내부에서의 this

- 함수 vs 메서드
  어떤 함수를 실행하는 방법은 여러가지가 있는데 가장 일반적인 방법은 두가지로 함수로서 호출하는 겨웅와 메서드로서 호출하는 경우가 있다. 프로그래밍 언어에서 하수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로 이둘을 구분하는 유일한 차이는 독립성이다. 함수는 그 자체로 독립적인 기능을 갖고 있지만 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.
  this 키워드에 다른 값을 부여하게 함으로써 이를 구현한다.

흔히 메서드를 객체의 프로퍼티에 할당된 함수로 이해한다. 나는 그렇다. 암초보
이것은 50의 정답이다. 어떤 함수를 객체의 프로퍼티에 할당한다고해서 그자체로 메서드가 되는 것이 아닌 객체의 메서드로서 호출한 경우에만 메서드로 동작하고 그렇지 않으면 함수로 동작한다.
//메서드란? 객체의 프로퍼티에 내부에 할당된 함수 중 메서드로서 호출된 함수를 메서드라고 한다??
예시를 보자

```
	var func = function(x){
		console.log(this, x)
	}
	func(1)
	//Window {0: Window, window: Window{...} Window 1
	var obj = {
		method: func
	};
	obj.method(2)
	//{method: ƒ}method: ƒ (x)[[Prototype]]: Object 2
```

변수 func에 익명함수를 할당하고 4번째 줄에서 func를 호출 했더니 this로 전역객체 window가 호출되었다.
obj라는 변수에 객체를 할당하고 그 객체에는 method 프로퍼티 앞에서 만든 함수를 할당했다.
obj의 method를 호출했더니 이번에는 this가 obj라고 한다. obj의 method 프로퍼티에 할당한 값과 func변수에 할당한 값은 모두 var func를 참조한다. 즉, 원래의 익명함수는 그대로인데 이를 변수에 담아 호출한 경우와 obj객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.

그렇다면 함수와 메서드로서의 호출을 구분해보자. 함수 앞에 점이 있는지를 여부만으로 간단하게 구분할 수 있다.
함수앞에 점이 있다면 메서드로 호출, 없으면 함수로 호출
obj.method : 메서드로 호출
func() : 함수로 호출
팩트) 다
메서드로서 호출 - 대괄호 표기법

```
	var obj = {
		method: function(x){
			console.log(this, x)
		}
	};
	obj.method(1);
	obj['method'](2);
```

### 메서드 내부에서 this

this에는 호출한 주체에 대한 정보가 담기게 되고 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체이다. 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 된다.
