# 01. 데이터 타입

## 01. 데이터 타입의 종류
- primitive type(기본형) : 숫자(number), 문자열(string), 불리언(boolean), null, undefined, Symbol(+ES6)
- reference type(참조형) : 객체(object), 배열(array), 함수(function), 날짜(Date), 정규표현식(RegExp),(Map, WeakMap, Set, WeakSet)(+ES6)


### 기본형, 참조형 구분 기준

- 기본형 : **값이 담긴** 주솟값을 바로 복제
- 참조형 : **값이 담긴 주솟값들로 이루어진 묶음**을 가리키는 주솟값(object)을 복제


### 기본형의 특징

- 기본형은 **불변성**을 띈다.
- 불변성 이해를 위한 배경 지식 : 메모리와 데이터, 식별자와 변수

### 참조형의 특징

- 기본적인 성질은 가변값
- 설정에 따라 변경 불가능한 경우도 있고, 불변값으로 활용하는 방안도 있다.

## 02. 데이터 타입에 관한 배경지식

### 메모리와 데이터

- 컴퓨터의 모든 데이터 0 과 1로 바꿔 기억한다.
- 0 또는 1만 표현할 수 있는 하나의 메모리조각 : 비트(bit)
- 각 비트(bit)는 고유한 **식별자**를 통해 위치를 확인 
- 표현 가능한 개수에 어느정도 제약이 따르더라도 크게 문제가 되지 않을 적정 공간 : 바이트(byte)
- 1byte = 8bit / 1 bit 0과 1 표현 -> 8bit 256개의 값 표현

- 결론 : 모든 데이터는 바이트(byte) 단위의 식별자, 더 정확히 **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있다.

### 식별자와 변수

- 변수 : '변할 수 있는 수'
- 식별자 : '어떤 데이터를 식별하는데 사용하는 이름(변수명)'

## 03. 변수 선언과 데이터 할당

### 변수 선언
```javascript
let a;
```
- 말로 표현 : "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"
- 변수의 추가 정의 : **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**

주소|1002
---|---|
데이터|이름:a, 값:x

### 데이터 할당
```javascript
let a = 'hello';
```
변수 영역

주소|1002
---|---|
데이터|이름:a, 값:@5002

데이터 영역

주소|5002
---|---|
데이터|'hello' 

순서 요약
- 변수 영역에 빈 공간@1002 확보
- 확보한 공간의 식별자를 a로 지정
- 데이터 영역의 빈 공간 @5002에 number형 1을 저장
- 변수 영역에 a라는 식별자 검색
- number형 1의 주소 @5002를 @1002의 공간에 대입

왜 이렇게 구현한 것일까?

미리 확보된 공간 내에서만 데이터 변환이 가능한 상황이라면, 변환한 데이티를 다시 저장하기 위해선 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'
이 선행되어야 한다. 해당 공간이 메모리의 상의 가장 마지막에 있는 경우 뒤쪽으로 공간만 늘리면 되지만, 중간에 있는 데이터를 늘려야하는 상황이 되면, 해당 공간보다 
뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야 한다.

```javascript
a = 'helloWorld';
```
주소|1002
---|---|
데이터|이름:a, 값:@5003

주소|5002|5003
---|---|---|
데이터|'hello'|'helloWorld'

- 기존 @5002에 'helloWorld를 할당하지 않고, 'helloWorld'를 @5003에 **새로 만들어** 별도의 공간에 저장하고, 그 주소를 변수 공간과 연결한다.


## 04. 기본형 데이터와 참조형 데이터

### 불변값
- 변수와 상수를 구분하는 성질 : **변경 가능성**
- 바꿀 수 있는 수 : 변수 , 바꿀 수 없는 수 : 상수
- **변수와 상수를 구분짓는** 변경 가능성의 대상 : **변수 영역** 메모리 , **불변성 여부**를 구분짓는 변경 가능성 대상 : **데이터 영역** 메모리

데이터 영역

주소|5002|5003
---|---|---|
데이터|'hello'|'helloWorld'

a라는 식별자를 가진 변수에 'helloWorld'를 재할당 하는 경우 기존의 'hello'라는 데이터 값을 'helloWorld'라는 값으로 재할당하는 것이 아닌, 새로 공간을 만들어 'helloWorld'를 저장해주었다.
즉, 기존의 'hello'라는 값 자체는 절대로 다른 값으로 변하지 않는 **'불변성'** 을 가진다.

### 가변값
```javascript
const obj1 = {
  a : 1,
  b : 'hello'
};
```

변수 영역

주소|1002
---|---|
데이터|이름:obj1, 값:@5002

데이터 영역

주소|5002|5003|5004
---|---|---|---|
데이터|@7100~?|1|'hello'

객체 @5002의 변수영역
주소|7100|7101
---|---|---|
데이터|이름:a,값:@5003|이름:b,값:@5004

순서 요약
- 변수 영역의 빈 공간@1002 확보후, 그 주소의 이름을 obj1로 지정
- 여러 개의 프로퍼티로 이루어진 데이터 그룹이므로, 별도의 변수 영역을 마련하고, 그 영역의 주소@7100~? @5002에 저장
- @7100 및 @7101에 각각 a와 b라는 프로퍼티 이름을 지정
- 데이터 영역에 숫자 1 검색후 없는 경우 @5003에 저장 후 주소를 @7100에 저장, 'hello'도 같은 방법으로 임으로 @5004에 저장하고, 주소를 @7101에 저장

기본형 데이터와의 차이점 : **'객체의 변수(프로퍼티)영역'이 별도로 존재한다.**

객체가 별도로 할애한 영역은 변수 영역이고, **'데이터 영역'은 기존의 메모리 공간을 그대로 활용**하고 있다.

결론:데이터 영역에 저장된 값은 모두 불변값이지만, 변수에는 다른 값을 얼마든지 대입이 가능하다. 이러한 부분 때문에 참조형 데이터는 불변하지 않다고 한다.


ex) 프로퍼티를 재할당 하는 경우 
```javascript
obj1.a = 2;
```

변수 영역

주소|1002
---|---|
데이터|이름:obj1, 값:@5002

데이터 영역

주소|5002|5003|5004|5005
---|---|---|---|---|
데이터|@7100~?|1|'hello'|2

객체 @5002의 변수영역
주소|7100|7101
---|---|---|
데이터|이름:a,값:@5005|이름:b,값:@5004

ex) 중첩된 참조형 데이터(객체)의 프로퍼티 할당

```javascript
const obj2 = {
  b : 2,
  arr : [2,3,4]
};
```

변수 영역

주소|1002,1003,1004|
---|---|
데이터|이름:obj2, 값:@5002

데이터 영역

주소|5002|5003|5004|5005|5006
---|---|---|---|---|---|
데이터|@7100~?|2|@8100~?|3|4|

객체 @5002의 변수영역

주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5004

배열 @5004의 변수 영역
주소|8100|8101|8102
---|---|---|---|
데이터|이름:0,값:@5003|이름:1,값:@5005|이름:2,값:@5006

순서 요약
- 변수 영역의 빈공간  @1002~@1004를 확보하고, 그 주소의 이름을 obj2로 지정한다.
- 임의의 데이터 공간(@5002)에 데이터를 저장하려는데, 이 데이터가 여러 개의 변수와 값들을 모아놓은 그룹(객체)이므로, 각 변수(프로퍼티)들을 저장하기 위해 별도의 변수 영역을 마련하고(@7100~?), 그 영역의 주소를 @5002에 저장한다.
- @7100에 이름 b를, @7101에 이름 arr을 지정한다.
- 데이터 영역에 숫자 2 를 검색하고 임의로 @5003에 저장하고, @5003을 @7100에 저장한다.
- @7101에 저장할 값은 데이터 그룹인 배열이기 때문에, 이 그룹의 내부 프로퍼티들을 저장하기 위해 별도의 변수영역 @8100~?을 마련하고, 이 영역의 주소정보를 @5003에 저장한뒤, @5003을 @7104에 저장한다.
- 벼열의 요소가 3개 이므로 변수 공간을 확보하고, 각각 인덱스를 부여한다.(0,1,2)
- 데이터 영역에서 숫자 2를 검색하고(@5003) 그 주소를 @8100에 저장한다.
- 데이터 영역에서 숫자 3은 없으므로, @5005에 저장하고, 이 주소를 @8101에 저장한다.
- 데이터 영역에서 숫자 4는 없으므로, @5006에 저장하고, 이 주소를 @8102에 저장한다.

ex) obj2.arr[1]의 값이 도출되는 과정
@1002 -> @5002 -> @7100~? -> @5004 -> @8100~? -> @5005 -> 3반환


**만약 재할당을 하는 경우, 어떻게 될까?**
```javascript
obj2.arr = 'str';
```
변수 영역

주소|1002,1003,1004|
---|---|
데이터|이름:obj2, 값:@5002

**데이터 영역**

할당전
주소|5002|5003|5004|5005|5006
---|---|---|---|---|---|
데이터|@7100~?|2|@8100~?|3|4|

할당후
주소|5002|5003|5004|5005|5006|5007
---|---|---|---|---|---|---|
데이터|@7100~?|2||3|4|'str'

**객체 @5002의 변수영역**

할당전
주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5004

할당후
주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5007

**배열 @5004의 변수 영역**

할당전
주소|8100|8101|8102
---|---|---|---|
데이터|이름:0,값:@5003|이름:1,값:@5005|이름:2,값:@5006


할당후

Garbage Collector가 수거해 간다.

Garbage Collector 수거 과정
- @5007에 문자열 'str'을 저장하고, 그 주소를 @7101에 저장한다.
- @5004는 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다.(참조 카운트:0)
- 참조 카운트가 0이 됨에 따라, @5004에 담겨있었던 @8100 ~ ?라는 값이 사라진다.
- @8100 ~? 각 데이터들의 참조 카운트가 0이되고, 이 데이터 역시 Garbage Collector 대상이 되어 함께 사라진다.

Garbag Collector 수거 시점 : 런타임 환경에 따라 **특정 시점**이나 **메모리 사용량이 포화 상태**에 임박할 때마다 자동으로 수거 대상들을 수거한다.


### 변수 복사 비교

```javascript
let a = 10;
let b = a;

let obj1 = {c:1,b:2};
let obj2 = obj1;
```
변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값:@5000|이름:obj1, 값:@5001|이름:obj2, 값:@5001

데이터 영역
주소|5000|5001|5002|5003
---|---|---|---|---|
데이터|10|@7100~?|1|2

객체 @5001의 변수 영역

주소|7100|7101
---|---|---|
데이터|이름:c,값:@5002|이름:d,값:@5003


ex) 객체의 프로퍼티를 변경하는 경우

```javascript
b = 11;
obj2.c = 3;
```
변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값:@5004|이름:obj1, 값:@5001|이름:obj2, 값:@5001

데이터 영역
주소|5000|5001|5002|5003|5004|5005
---|---|---|---|---|---|---|
데이터|10|@7100~?|1|2|11|3

객체 @5001의 변수 영역

주소|7100|7101
---|---|---|
데이터|이름:c,값:@5005|이름:d,값:@5003

- 기본형 데이터를 복사한 변수 b의 값을 바꾸면, @1002의 값이 달라지는 반면, 참조형 데이터는 @1003의 값이 달라지지 않았다.
```javascript
a!==b
obj1 === obj2
```

ex) 객체 자체를 변경하는 경우

```javascript
let a = 10;
let b = a;
const obj1 = {c:1,d:2};
const obj2 = obj1;

b = 11;
obj2 = {c:20,d:30};
```

변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값@5004|이름:obj1,값:@5001|이름:obj2,값:@5005

데이터 영역
주소|5000|5001|5002|5003|5004|5005|5006|5007
---|---|---|---|---|---|---|---|---|
데이터|10|@7100~?|1|2|11|@8100~?|20|30

객체 @5001

주소|7100|7101
---|---|---|
데이터|@5002|@5003

객체 @5005

주소|8100|8101
---|---|---|
데이터|@5006|@5007

- 기본형 데이터 @1001의 값도 달라지고, 참조형 데이터 @1003의 값도 달라졌다.
- 결론 : 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 **참조형 내부의 프로퍼티**를 변경할 때만 성립한다.


