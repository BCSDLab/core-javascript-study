# 01. 데이터 타입

## 01. 데이터 타입의 종류
- primitive type(기본형) : 숫자(number), 문자열(string), 불리언(boolean), null, undefined, Symbol(+ES6)
- reference type(참조형) : 객체(object), 배열(array), 함수(function), 날짜(Date), 정규표현식(RegExp),(Map, WeakMap, Set, WeakSet)(+ES6)


### 기본형, 참조형 구분 기준

- 기본형 : **값이 담긴** 주솟값을 바로 복제
- 참조형 : **값이 담긴 주솟값들로 이루어진 묶음**을 가리키는 주솟값(object)을 복제


### 기본형의 특징

- 기본형은 **불변성**을 띈다.
- 불변성 이해를 위한 배경 지식 : 메모리와 데이터, 식별자와 변수

### 참조형의 특징

- 기본적인 성질은 가변값
- 설정에 따라 변경 불가능한 경우도 있고, 불변값으로 활용하는 방안도 있다.

## 02. 데이터 타입에 관한 배경지식

### 메모리와 데이터

- 컴퓨터의 모든 데이터 0 과 1로 바꿔 기억한다.
- 0 또는 1만 표현할 수 있는 하나의 메모리조각 : 비트(bit)
- 각 비트(bit)는 고유한 **식별자**를 통해 위치를 확인 
- 표현 가능한 개수에 어느정도 제약이 따르더라도 크게 문제가 되지 않을 적정 공간 : 바이트(byte)
- 1byte = 8bit / 1 bit 0과 1 표현 -> 8bit 256개의 값 표현

- 결론 : 모든 데이터는 바이트(byte) 단위의 식별자, 더 정확히 **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있다.

### 식별자와 변수

- 변수 : '변할 수 있는 수'
- 식별자 : '어떤 데이터를 식별하는데 사용하는 이름(변수명)'

## 03. 변수 선언과 데이터 할당

### 변수 선언
```javascript
let a;
```
- 말로 표현 : "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"
- 변수의 추가 정의 : **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**

주소|1002
---|---|
데이터|이름:a, 값:x

### 데이터 할당
```javascript
let a = 'hello';
```
변수 영역

주소|1002
---|---|
데이터|이름:a, 값:@5002

데이터 영역

주소|5002
---|---|
데이터|'hello' 

순서 요약
- 변수 영역에 빈 공간@1002 확보
- 확보한 공간의 식별자를 a로 지정
- 데이터 영역의 빈 공간 @5002에 number형 1을 저장
- 변수 영역에 a라는 식별자 검색
- number형 1의 주소 @5002를 @1002의 공간에 대입

왜 이렇게 구현한 것일까?

미리 확보된 공간 내에서만 데이터 변환이 가능한 상황이라면, 변환한 데이티를 다시 저장하기 위해선 '확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'
이 선행되어야 한다. 해당 공간이 메모리의 상의 가장 마지막에 있는 경우 뒤쪽으로 공간만 늘리면 되지만, 중간에 있는 데이터를 늘려야하는 상황이 되면, 해당 공간보다 
뒤에 저장된 데이터들을 전부 뒤로 옮기고, 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야 한다.

```javascript
a = 'helloWorld';
```
주소|1002
---|---|
데이터|이름:a, 값:@5003

주소|5002|5003
---|---|---|
데이터|'hello'|'helloWorld'

- 기존 @5002에 'helloWorld를 할당하지 않고, 'helloWorld'를 @5003에 **새로 만들어** 별도의 공간에 저장하고, 그 주소를 변수 공간과 연결한다.


## 04. 기본형 데이터와 참조형 데이터

### 불변값
- 변수와 상수를 구분하는 성질 : **변경 가능성**
- 바꿀 수 있는 수 : 변수 , 바꿀 수 없는 수 : 상수
- **변수와 상수를 구분짓는** 변경 가능성의 대상 : **변수 영역** 메모리 , **불변성 여부**를 구분짓는 변경 가능성 대상 : **데이터 영역** 메모리

데이터 영역

주소|5002|5003
---|---|---|
데이터|'hello'|'helloWorld'

a라는 식별자를 가진 변수에 'helloWorld'를 재할당 하는 경우 기존의 'hello'라는 데이터 값을 'helloWorld'라는 값으로 재할당하는 것이 아닌, 새로 공간을 만들어 'helloWorld'를 저장해주었다.
즉, 기존의 'hello'라는 값 자체는 절대로 다른 값으로 변하지 않는 **'불변성'** 을 가진다.

### 가변값
```javascript
const obj1 = {
  a : 1,
  b : 'hello'
};
```

변수 영역

주소|1002
---|---|
데이터|이름:obj1, 값:@5002

데이터 영역

주소|5002|5003|5004
---|---|---|---|
데이터|@7100~?|1|'hello'

객체 @5002의 변수영역
주소|7100|7101
---|---|---|
데이터|이름:a,값:@5003|이름:b,값:@5004

순서 요약
- 변수 영역의 빈 공간@1002 확보후, 그 주소의 이름을 obj1로 지정
- 여러 개의 프로퍼티로 이루어진 데이터 그룹이므로, 별도의 변수 영역을 마련하고, 그 영역의 주소@7100~? @5002에 저장
- @7100 및 @7101에 각각 a와 b라는 프로퍼티 이름을 지정
- 데이터 영역에 숫자 1 검색후 없는 경우 @5003에 저장 후 주소를 @7100에 저장, 'hello'도 같은 방법으로 임으로 @5004에 저장하고, 주소를 @7101에 저장

기본형 데이터와의 차이점 : **'객체의 변수(프로퍼티)영역'이 별도로 존재한다.**

객체가 별도로 할애한 영역은 변수 영역이고, **'데이터 영역'은 기존의 메모리 공간을 그대로 활용**하고 있다.

결론:데이터 영역에 저장된 값은 모두 불변값이지만, 변수에는 다른 값을 얼마든지 대입이 가능하다. 이러한 부분 때문에 참조형 데이터는 불변하지 않다고 한다.


ex) 프로퍼티를 재할당 하는 경우 
```javascript
obj1.a = 2;
```

변수 영역

주소|1002
---|---|
데이터|이름:obj1, 값:@5002

데이터 영역

주소|5002|5003|5004|5005
---|---|---|---|---|
데이터|@7100~?|1|'hello'|2

객체 @5002의 변수영역
주소|7100|7101
---|---|---|
데이터|이름:a,값:@5005|이름:b,값:@5004

ex) 중첩된 참조형 데이터(객체)의 프로퍼티 할당

```javascript
const obj2 = {
  b : 2,
  arr : [2,3,4]
};
```

변수 영역

주소|1002,1003,1004|
---|---|
데이터|이름:obj2, 값:@5002

데이터 영역

주소|5002|5003|5004|5005|5006
---|---|---|---|---|---|
데이터|@7100~?|2|@8100~?|3|4|

객체 @5002의 변수영역

주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5004

배열 @5004의 변수 영역
주소|8100|8101|8102
---|---|---|---|
데이터|이름:0,값:@5003|이름:1,값:@5005|이름:2,값:@5006

순서 요약
- 변수 영역의 빈공간  @1002~@1004를 확보하고, 그 주소의 이름을 obj2로 지정한다.
- 임의의 데이터 공간(@5002)에 데이터를 저장하려는데, 이 데이터가 여러 개의 변수와 값들을 모아놓은 그룹(객체)이므로, 각 변수(프로퍼티)들을 저장하기 위해 별도의 변수 영역을 마련하고(@7100~?), 그 영역의 주소를 @5002에 저장한다.
- @7100에 이름 b를, @7101에 이름 arr을 지정한다.
- 데이터 영역에 숫자 2 를 검색하고 임의로 @5003에 저장하고, @5003을 @7100에 저장한다.
- @7101에 저장할 값은 데이터 그룹인 배열이기 때문에, 이 그룹의 내부 프로퍼티들을 저장하기 위해 별도의 변수영역 @8100~?을 마련하고, 이 영역의 주소정보를 @5003에 저장한뒤, @5003을 @7104에 저장한다.
- 벼열의 요소가 3개 이므로 변수 공간을 확보하고, 각각 인덱스를 부여한다.(0,1,2)
- 데이터 영역에서 숫자 2를 검색하고(@5003) 그 주소를 @8100에 저장한다.
- 데이터 영역에서 숫자 3은 없으므로, @5005에 저장하고, 이 주소를 @8101에 저장한다.
- 데이터 영역에서 숫자 4는 없으므로, @5006에 저장하고, 이 주소를 @8102에 저장한다.

ex) obj2.arr[1]의 값이 도출되는 과정
@1002 -> @5002 -> @7100~? -> @5004 -> @8100~? -> @5005 -> 3반환


**만약 재할당을 하는 경우, 어떻게 될까?**
```javascript
obj2.arr = 'str';
```
변수 영역

주소|1002,1003,1004|
---|---|
데이터|이름:obj2, 값:@5002

**데이터 영역**

할당전
주소|5002|5003|5004|5005|5006
---|---|---|---|---|---|
데이터|@7100~?|2|@8100~?|3|4|

할당후
주소|5002|5003|5004|5005|5006|5007
---|---|---|---|---|---|---|
데이터|@7100~?|2||3|4|'str'

**객체 @5002의 변수영역**

할당전
주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5004

할당후
주소|7100|7101
---|---|---|
데이터|이름:b,값:@5003|이름:arr,값:@5007

**배열 @5004의 변수 영역**

할당전
주소|8100|8101|8102
---|---|---|---|
데이터|이름:0,값:@5003|이름:1,값:@5005|이름:2,값:@5006


할당후

Garbage Collector가 수거해 간다.

Garbage Collector 수거 과정
- @5007에 문자열 'str'을 저장하고, 그 주소를 @7101에 저장한다.
- @5004는 더이상 자신의 주소를 참조하는 변수가 하나도 없게 된다.(참조 카운트:0)
- 참조 카운트가 0이 됨에 따라, @5004에 담겨있었던 @8100 ~ ?라는 값이 사라진다.
- @8100 ~? 각 데이터들의 참조 카운트가 0이되고, 이 데이터 역시 Garbage Collector 대상이 되어 함께 사라진다.

Garbag Collector 수거 시점 : 런타임 환경에 따라 **특정 시점**이나 **메모리 사용량이 포화 상태**에 임박할 때마다 자동으로 수거 대상들을 수거한다.


### 변수 복사 비교

```javascript
let a = 10;
let b = a;

let obj1 = {c:1,b:2};
let obj2 = obj1;
```
변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값:@5000|이름:obj1, 값:@5001|이름:obj2, 값:@5001

데이터 영역
주소|5000|5001|5002|5003
---|---|---|---|---|
데이터|10|@7100~?|1|2

객체 @5001의 변수 영역

주소|7100|7101
---|---|---|
데이터|이름:c,값:@5002|이름:d,값:@5003


ex) 객체의 프로퍼티를 변경하는 경우

```javascript
b = 11;
obj2.c = 3;
```
변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값:@5004|이름:obj1, 값:@5001|이름:obj2, 값:@5001

데이터 영역
주소|5000|5001|5002|5003|5004|5005
---|---|---|---|---|---|---|
데이터|10|@7100~?|1|2|11|3

객체 @5001의 변수 영역

주소|7100|7101
---|---|---|
데이터|이름:c,값:@5005|이름:d,값:@5003

- 기본형 데이터를 복사한 변수 b의 값을 바꾸면, @1002의 값이 달라지는 반면, 참조형 데이터는 @1003의 값이 달라지지 않았다.
```javascript
a!==b
obj1 === obj2
```

ex) 객체 자체를 변경하는 경우

```javascript
let a = 10;
let b = a;
const obj1 = {c:1,d:2};
const obj2 = obj1;

b = 11;
obj2 = {c:20,d:30};
```

변수 영역
주소|1000|1001|1002|1003
---|---|---|---|---|
데이터|이름:a,값:@5000|이름:b,값@5004|이름:obj1,값:@5001|이름:obj2,값:@5005

데이터 영역
주소|5000|5001|5002|5003|5004|5005|5006|5007
---|---|---|---|---|---|---|---|---|
데이터|10|@7100~?|1|2|11|@8100~?|20|30

객체 @5001

주소|7100|7101
---|---|---|
데이터|@5002|@5003

객체 @5005

주소|8100|8101
---|---|---|
데이터|@5006|@5007

- 기본형 데이터 @1001의 값도 달라지고, 참조형 데이터 @1003의 값도 달라졌다.
- 결론 : 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 **참조형 내부의 프로퍼티**를 변경할 때만 성립한다.

##05. 불변 객체

### 불변 객체를 만드는 간단한 방법

- 참조형 데이터의 가변? 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립
- **기존 데이터는 변하지 않는다.**

불변 객체가 필요한 상황 : 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우

가변성으로 인한 문제점 예시
```javascript
const user = {
  name:'sangyun',
  gender:'male'
};

const changeName = (user,name) => {
  let newUser = user;
  newUser.name = name;
  return newUser;
}

let user2 = changeName(nuser,'daeyoung');

console.log(user.naem,user2.name);
console.log(user === user2);
```
출력값

```javascript
daeyoung daeyoung

true
```

- user의 이름은 sangyun으로, user1의 이름은 daeyoung으로 갖도록 하고 싶은데, 참조형 참조 방식 특성 상 같은 주소를 갖기 때문에 데이터가 변경되면, 같이 변경되는 문제점이 발생한다.


**해결방법1**

```javascript
const changeName = (user,name) => {
  let newUser = {
    name,
    gender:'male'
  }
  return newUser
}
```

changeName 함수내에서 새로운 객체를 반환해주면

출력값

```javascript
sangyun daeyoung

false
```

- 참조로 인한 첫 예제에서 등장했던 문제가 해결된다
- user와 user2는 완전히 서로 다른 객체이다.


**해결방법2**

해결방법1은 대상 객체에 대한 정보가 많을수록, 변경해야 할 정보가 많을수록 일일히 다 입력을 해주어야 한다.

```javascript
const copyObject = (object) => {

  const newObject = {};
 
  for(let prop in object){
    newObject[prop] = object[prop];
  }
  
  return newObject;
}
```
- for ~ in 을 사용해서 객체의 프로퍼티들을 복사해준다.


협업을 하는 모든 개발자들이 user 객체 내부의 변경이 필요할 때는 무조건 copyObject 함수를 사용하기로 합의하고 그 규칙을 지킨다는 전제하에서는 user객체가 곧 **불변 객체** 라고 볼 수 있다. 하지만 모두가 이 규칙을 지키라는 인간의 신뢰에만 의존하는 것은 불가능하기 때문에, immutable.js, baobab.js등의 라이브러리를 통해 시스템적으로 제약을 거는 편이 더 안전하다.

### 얕은 복사와 깊은 복사

- 얕은 복사 : 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사 : 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법


copyObject함수의 얕은 복사 

**중첩된 객체**에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다.

```javascript
const copyObject = (object) => {

  const newObject = {};
 
  for(let prop in object){
    newObject[prop] = object[prop];
  }
  
  return newObject;
}

const user = {
  name:'Sangyun',
  urls:{
    portfolio:'http://github.com/abc,
    blog:'http://blog.com,
    facebook:'http://facebook.com/abc
  }
};

user2 = copyObject(user);

user2.name = 'Jung';
user.urls.portfolio = 'http://portfolio.com;
user2.urls.blog = '';

console.log(user.name === user2.name);
console.log(user.urls.portfolio === user2.urls.portfolio);
console.log (user.urls.blog === user2.urls.blog);
```
출력값
```javascript
false

true

true
```

- user2의 name 프로퍼티를 바꿔도 user의 name 프로퍼티는 변하지 않는다.
- user.urls.portfolio, user2.urls.blog의 값은 원본과 사본 중 어느 쪽을 바꾸더라도 다른 한쪽의 값도 함께 바뀐다.

결론 : user 객체에 직접 속한 프로퍼티(name)에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면에, 한 단계 더 들어간 urls의 내부 프로퍼티들은 **기존 데이터를 그대로 참조**하고 있다.


어떻게 할 수 있을까?

- user.urls 프로퍼티에 대해서도 불변 객체를 만들 필요가 있다.

**해결방법 1**
```javascript

 user2.urls = copyObject(user.urls);
 user.urls.portfolio = "http://githug.com/def";
 user.urls.blog = "http://blog1.com";
 
 console.log(user2.urls.portfolio === user.urls.portfolio);
 console.log(user2.urls.blog === user.urls.blog);

```

출력값
```javascript
false

false
```

- user의 내부 프로퍼티인 urls도 copyObject를 이용해서 객체를 복사해준다 : 깊은복사
- 깊은 복사를 해주면 data 영역의 주솟값이 서로 다른 것을 참조하게 된다.


**해결방법 2**

깊은 복사 함수 정의

```javascript
const copyObjectDeep = function(target){
  const result = {};
  
  if(typeof target === 'object' && target!=null){
    for(let prop in target){
      result[prop] = copyObject(target[prop]);
    }
  }else {
    result = target;
  }
  return result;
}

```

- target의 타입이 object이거나 target이 null이 아닌경우 반복문을 통해 target의 내부 프로퍼티를 깊은 복사를 해준다.


**해결방법 3**

객체를 JSON문법으로 표현된 문자열로 전환했다가 다시 JSON객체로 바꾸는 것
```javascript
  const copyObjectViaJSON = function(target){
    return JSON.parse(JSON.stringify(target));
  };
```


단, 객체 내부에 또 객체가 있는 경우
```javascript
  const obj3 = {
    a:{
      b:{
        c:12
      }
    }
  }
obj4 = copyObjectDeep(obj3);

obj4.a.b.c = 11;

console.log(obj3);
console.log(obj4);
```
출력값

```javascript
{ a: { b: { c :11 } } }
{ a: { b: { c :11 } } }
```

- 원본과 복사본의 값이 같이 변경된다.

```javascript
  const obj3 = {
    a:{
      b:{
        c:12
      }
    }
  }
obj4 = copyObjectViaJSON(obj3);

obj4.a.b.c = 11;

console.log(obj3);
console.log(obj4);
```
출력값

```javascript
{ a: { b: { c :12 } } }
{ a: { b: { c :11 } } }
```

- JSON.parse를 통해 변경하면 원본과 복사본이 다르게 나온다.

## 06. undefined와 null

자바스크립트에서 '없음'을 나타내는 값 undefined와 null이 존재한다.

undefined

- undefined는 사용자가 명시적으로 지정할 수도 있지만, 값이 존재하지 않을 때 **자바스크립트 엔진이 자동으로 부여**하는 경우도 있다.
- 자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로 그렇게 하지 않았을 때 **undefined를 반환** 한다.


3가지 경우가 존재

- 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
- return 문이 없거나 호출되지 않는 함수의 실행 결과

```javascript
  //1번
  let a;
  console.log(a);
  //2번
  const obj = {};
  console.log(obj.a);
  //3번
  function hello(){};
  console.log(hello());
```
출력값

```javascript
undefined

undefined

undefined

```

**Undefined와 배열**
```javascript
  const arr1 = [];
  arr1.length = 3;
  console.log(arr1);
  
  const arr2 = newArray(3);
  console.log(arr2);
  
  const arr3 = [undefined,undefined,undefined];
  console.log(arr3);
```
출력값

```javascript
[<3 empty items>]
[<3 empty items>]
[undefined,undefined,undefined]
```

- '비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다르다.
- '비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.

**빈 요소와 배열의 순회**
```javascript
  const arr1 = [undefined,1];
  const arr2 = [];
  arr2[1] = 1;
  
  console.log("arr1");
  arr1.forEach((index,value)=>{
    console.log(index,value);
  });
  
  console.log("arr2");
  arr1.forEach((index,value)=>{
    console.log(index,value);
  });
```
출력값

```javascript
arr1

undefined 0

1 1

arr2

1 1
```

- 사용자가 직접 undefined를 할당한 arr1에 대해서는 일반적으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력한다.
- arr2에 대한 결과에선, 각 메서드들이 비어있는 요소에 대해서는 어떠한 처리도 하지 않고 건너뛰었다.

결론 : '배열도 객체이다.'

**undefined의 의미 차이***
- 사용자가 명시적으로 부여한 경우와 비어있는 요소에 접근하려 할 때 반환되는 두 경우 'unefined'의 의미를 구분한다.
- 전자의 undefined는 '비어있음'을 의미하지만, **하나의 값으로 동작하기 때문에 이때의 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되고**, 순회의 대상이 될 수 있다.
- 후자의 undefined는 해당 프로퍼티 내지 배열의 키값(인덱스)**자체가 존재하지 않음을 의미**한다.


결론

'비어있음'을 명시적으로 나타내고 싶을 땐, undefined가 아닌 null을 사용하면 된다.
이런 규칙을 따르는 한 undefined는 오직 '**값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값**'으로서만 존재한다.

주의할 점

- typeof null은 object

```javascript
  n == undefined  //true
  n === undefined //false
```
