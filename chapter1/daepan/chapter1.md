# 데이터 타입과 종류

## JS 데이터 타입의 종류

| Data type | Primitive type | Reference type |
| --------- | -------------- | -------------- |
|           | Number         | Array          |
|           | String         | Function       |
|           | Boolean        | Date           |
|           | null           | RegExp         |
|           | undefined      | Map, WeakMap   |
|           | Symbol         | Set, WeakSet   |

<!---책에서는 처음에 데이터 타입의 종류를 설명해주는데 둘로 나누어주었다.
이둘의 무슨 차이점을 두고 나눈 것인가--->

-차이점
기본형은 할당이나 연산시 복제되고 참조형은 참조된다.
하지만 엄밀히 말하면 모두 복제가 된다.
단, 기본형은 **값이 담긴 주솟값**을 바로 복제하지만, 참조형은 **값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값**을 복제한다는 점이 다르다.

<!--이것을 보았을 때 이해한 것은 값이 담긴 주솟값(포인터)를 기본형은 값이 담긴 주솟값을 바로 복사한다는 것은 이해된다. 참조형은 값이 담긴 주솟값의 묶음을 가리키는 주솟값, 이게 조금 이해가 안된다..-->

기본형은 불변성을 띈다.
기본형은 숫자 10을 담은 변수 a에 다시 숫자 숫자 15를 담으면 a의 값은 15가 된다.(변하는데?)
불변성을 이해하기 위해서는 메모리와 데이터에 대한 지식과 식별자와 변수의 개념을 구분해야한다.

## 데이터 타입에 대한 배경지식

컴퓨터는 모든 데이터를 0또는 1로 분석하고 이해한다.
**0또는 1만 표현할 수 있는 하나의 메모리 조각**을 **비트**라고한다.
메모리는 매우 많은 비트로 구성되있는데 **각 비트는 고유한 식별자를 통해 위치를 확인**할 수 있다.
그런데 고작 0이나 1을 표현하는 비트 단위로 위치를 확인하는 것은 비효율적이다.
그보다는 몇 개의 묶음을 하나의 단위로 여긴다면 표현할 수 있는 값도 늘어나게 되어 위치를 찾는 것에 있어 검색시간도 줄일 수 있게된다.

위와 같은 장점도 있지만 단점으로는 낭비되는 비트가 생기기도 한다.
"자주 사용하지 않을 데이터를 표현하기 위해 빈 공간을 남겨 놓기보다는 표현 가능한 개수에 어느 정도 제약이 따르더라도 크게 문제가 되지 않을 적정한 공간을 묶는 편이 좋다."
위의 말을 해석해보면 무작정 남기는 것도 효율적이지 않고 그렇다고 다 묶어버리기에도 비효율적이다.
그러니 그에 대한 적절한 묶는 기준이 필요할 것 같아 만들어진 개념이 **바이트(Byte)** 이다.
1바이트는 8비트로 구성되어 있으며 1비트 마다 0또는 1의 두가지 값을 표현하므로 2^8=256개의 값을 표현할 수 있다.
(2바이트는 2^16=65536개의 값을 표현할 수 있다.)

C/C++.자바등과 같은 정적 타입 언어는 메모리의 낭비를 최소화 하기 위해 데이터 타입별로 할당할 메모리의 영역을 2바이트, 4바이트 등으로 나누어 정하였다.
`만약 2바이트 크기의 정수형 타입(short)은 0을 포함해 -32768~+32768의 숫자를 저장할 수 있다. 그 이상을 입력하게 되면은 오류가 나거나 잘못된 값이 저장되게 된다. 이를 막기 위해서는 4바이트 크기의 정수형 타입(int)로 형변환을해야한다. `

한편 메모리 용량이 과거보다 월등히 커진 상황에 등장한 JS는 상대적으로 메모리 관리에 대한 압박에 자유로웠다. 그래서 메모리 공간을 좀 더 넉넉하게 할당했다.
숫자의 경우 정수형인지 부동소수형인지를 구분하지않고 64비트, 즉 8바이트를 확보한다. (형변환에서 자유롭다)여기까지가 숫자형 데이터를 정하는 방법의 개념이다.
앞서 각 비트트 고유한 식별자를 지닌다고 했을 때 그럼 바이트는? 이라고 생각했다.
바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다.
모든 데이터는 바이트 단위의 식별자, 더 정확하게 **메모리의 주솟값**을 통해
서로를 구분하고 연결할 수 있는 것이다.

### 식별자와 변수

변수 : 변할 수 있는 데이터
식별자 : 어떤 데이터를 식별하는데 사용하는 이름, **변수명**

## 변수 선언과 데이터 할당

### 변수 선언

`var a;`
위의 예제를 풀어쓰면 **변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다**라고 할 수 있다.
변할 수 있는 데이터이니 선언할 때는 undefined이더라도 나중에 다른 값으로 바꾸면 된다.
이렇게 보면 변수란 결국 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이라고 생각해두자
이 공간에 숫자를 담았다가 문자열을 담는 등의 다양한 명령을 내릴 수 있다.

그렇다면 메모리 영역에서는 어떤작업을 수행할까?
간략히 표현하면
|주소 | ...1002 |1003|1004...  
| ---|----|---------|-------|
| 데이터||이름: a / 값: ||

변수 선언을 받은 컴퓨터는 메모리에서 비어있는 공간 하나를 확보하고, 이 공간의 이름을 a라고 지정한다.

### 데이터 할당

1 .변수 a 선언, 변수 a에 데이터할당
`var a;`
`a='abc';` 2. 변수 a선언과 할당을 한문자으로 표현
`var a = 'abc';`

위에 2개의 방식 모두 JS 엔진은 결국 같은 동작을 수행한다.
메모리에서 비어있는 공간을 확보하고 그 공간의 이름을 설정하는 선언 과정과 같이 말이다.
이어서 할당 과정.
a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것 같다.

하지만 실제로는 해당 위체에 문자열 'abc'를 저장하지 않는다.
데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고 그 주소를 변수 영역에 정하는 식으로 이루어진다.
데이터의 성질에 따라 변수영역과 데이터 영역으로 나누어 보자

변수영역
| 주소 |...1002| 1003 |1004...  
 | ---|----|---------|-------|
|데이터||이름: a, 값: @5003|

데이터 영역
| 주소 |...5002| 5003|5004...
| ---|----|---------|-------|
|데이터| | 'abc'|

왜 변수 영역에 값을 직접 대입하지 않고 굳이 한 단계를 더 거치는 걸까?
이는 데이터 변환을 자유롭게 할수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과이다.
왜 와이?
자바스크립트는 숫자형 데이터에 대해 64비트의 공간을 확보한다. 반면 문자열은 특별히 정해진 규격이 없다.
한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 각각 필요한 메모리 용량이 가변적이며 전체 글자 수 역시 가변적이다.

만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면, 변환한 데이터를 다시 저장하기 위해서는
**확보된 공간을 변환된 데이터크기에 맞게 늘리는 작업**을 선행해야 할 것이다.
해당 공간이 메모리 상의 가장 마지막에 있었다면 뒤쪽으로 늘리기만 하면 큰 상관이 없지만 만약 중간에 있는 데이터를 늘려야하는 상황에서는 해당 공간보다는 뒤에 저장된 데이터를 전부 뒤로 옮기고 이동시킨 주소를 각 식별자에 다시 연결하는 작업을 해야한다. 이렇게 되면 컴퓨터의 연산이 많아져서 비효율적이다.
그러기에 효율적으로 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.
만약 'abc' 문자열의 마지막에 'def'를 추가하라고한다면, 컴퓨터는 앞서 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 'abcdef'를 새로 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결한다.

변수영역
| 주소 |...1002| 1003 |1004...  
 | ---|----|---------|-------|
|데이터||이름: a, 값: @5004|

데이터 영역
| 주소 |...5002| 5003|5004...
| ---|----|---------|-------|
|데이터| | 'abc'|'abcdef'|

다른 예로 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황을 생각해보자
각 변수를 별개로 인식하려면 500개의 변수 공간을 확보하는 것은 불가피하지만
각 변수 공간마다 매번 숫자 5를 할당하려고하면 숫자형은 8바이트 이므로 총 4000바이트를 사용해야하는가?
그 대신 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력한다면?
예를 들어, 주소 공간의 크기가 2바이트라고 한다면 1008바이트만 이용하면 된다. 이처럼 변수 영역과
데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다

<!--데이터 영역에서의 변수값이 중복되면 이를 재사용해서 참조할 수 있게 해준다라는 뜻을 이해된다.-->

## 기본형 데이터와 참조형 데이터

### 불변값

변수와 상수를 구분하는 성질은 valuable이다. 바꿀 수 있으면 변수, 못 바꾼다면 상수이다.
변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역 메모리**이다.
변수 영역 메모리이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 잇는지 여부가 관건이다.
반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역**의 메모리이다
기본형 데이터는 초반에 모두 불변값이라고 했다. 그 중에 숫자와 문자열로 예를 들어 불변성의 개념을 알아보자

```
01 var a='abc';
02 a = a +'def';
03
04 var b=5;
05 var c=5;
06 b=7
```

(01 line~02 line)
변수 a에 문자열 'abc'를 할당 했다가 뒤에 'def'를 추가하면, 'abcdef'로 바뀌는 것이 아닌 새로운 문자열 'abcdef'를 생성하고 그 주소를 변수 a에 저장한다. 'abc' 와 'abcdef'는 완전히 별개의 데이터이다.

(04 line ~ 06 line)
변수 b에 숫자 5를 할당한다. 그러면 컴퓨터는 일단 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장하고 그 주소를 b에 저장한다. c에 5를 저장하는 경우에는 이미 데이터 영역에 5가 존재하기에 5에 대한 주소값을 c에 저장한다.
그리고 b를 7로 변경한다면 기존에 저장된 5자체를 7로 바꾸는 것이 아닌 데이터 영역에 7이 존재한다면 7의 주솟값을, 없다면 7을 새로 만들고 그 주솟값을 b에 저장한다.
결국 5와 7모두 다른 값으로 변경할 수 없다.

이처럼 문자열 값도 한 번 만든 값을 바꿀 수 없고 숫자 값도 다른 값으로 변경할수 없다.
변경은 새로 만드는 동작을 통해서만 이루어진다. 이것이 불변값의 성질이다.
한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않을 것이다.

### 가변값

기본형이 불변값이라면 참조형들은 모두 변할 수 있이지 않을까라는 이분적 사고방식이 발동한다.
참조형 데이터에 대한 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고,
불변값으로 활용하는 방안도 있다.
불변값으로 활용하는 예외적인 방안은 나중에 다룰 예정!
참조형 데이터를 변수에 할당하는 과정부터 확인해 보자

```
var obj1={
	a:1,
	b:'bbb'
};
```

변수영역
| 주소 |...1002| 1003 |1004...  
 | ---|----|---------|-------|
|데이터||이름: obj1, 값: @5002|

데이터 영역
| 주소 |...5002| 5003|5004...
| ---|----|---------|-------|
|데이터| @7102~?| 1|'bbb'|

객체 @5002의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: a, 값: @5003 |이름: b, 값: @5004|

- 변수 영역의 빈공간(@1003), 그 주소의 이름을 obj1로 지정한다.
- 임의의 데이터 저장 공간(@5002)에 데이터를 저장하려고 보니 여러개의 프로퍼티로 이뤄진 데이터 그룹이다.이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7102~?)를 @5002에 저장한다.
- @7103및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다.
- 데이터 영역에서 숫자 1을 검색, 없으므로 @5003에 저장하고 이 주소를 @7103에 저장
- 'bbb'역시 없으므로 임의로 @5004 에 저장하고 이 주소를 @7104에 저장

기본형 데이터와의 차이는 객체의 변수(프로퍼티) 영역이 별도로 존재한다는 점이다.
객체가 별도로 할애한 영역은 변수 영역일 뿐 데이터 영역은 기존의 메모리 공간을 그대로 활용하고 있다.
데이터 영역에 저장된 값은 모두 불변값이다. 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다.
바로 이부분에서 흔히 참조형 데이터는 불변하지 않다. 가변값이라고 한다는 것이다.
프로퍼티의 재할당의 예제를 보자

```
var obj1={
	a:1,
	b:'bbb'
};
obj1.a = 2
```

obj1의 a프로퍼티에 숫자 2를 할당하려고 한다.
데이터 영역에서 숫자 2를 검색한다. 검색 결과가 없으므로 빈 공간인 @5005에 저장하고, 이 주소를 @7103에 저장한다. 이를 표로 보자
변수영역
| 주소 |...1002| 1003 |1004...  
 | ---|----|---------|-------|
|데이터||이름: obj1, 값: @5002|

데이터 영역
| 주소 |...5002| 5003|5004|5005...
| ---|----|---------|-------|---|
|데이터| @7102~?| 1|'bbb'|2|

객체 @5002의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: a, 값: @5005(<=@5003) |이름: b, 값: @5004|

위의 객체 @5002의 변수 영역에 대해서 새로운 객체가 생성되는 것이 아닌 기존의 객체 내부의 값만 바뀐 것을
확인할 수 있다.

참조형 객체 안에 참조형을 넣는 경우를 생각해보자
참고로 이런 경우는 중첩객체라고한다.

```
var obj={
	x:3,
	arr:[3,4,5]
}
```

변수영역
| 주소 |...1002| 1003 |1004...  
 | ---|----|---------|-------|
|데이터||이름: obj, 값: @5002|

데이터 영역
| 주소 |...5002| 5003|5004|5005 | 5006...
| ---|----|---------|-------|---|---|
|데이터| @7102~?| 3|@8102~?|4|5|

객체 @5002의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: x, 값: @5003 |이름: arr, 값: @5004|

객체 @5004의 변수 영역
| 주소 |...8102| 8103 |8104...  
 | ---|----|---------|-------|
|데이터|이름: 0, 값: @5003 |이름: 1, 값: @5005|이름:2 ,값:@5006

만약 이 상태에서 다음과 같이 재할당 명령을 내리면 어떻게 될까?
`obj.arr='str`
@5007에 문자열 'str'을 저장하고 그 주소를 @7104에 저장한다.
그렇다면 @5004는 더 이상 자신의 주소를 참조하는 변수가 없게 된다.
어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수는 참조카운트라고 한다.
참조조카운트가 0이 된 메모리주소는 가비지 컬렉터의 수거 대상이 된다.
가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다.
수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

### 변수 복사 비교

동작 방식을 알았으니 이제 본격적으로 기본형 데이터와 참조형 데이터의 차이를 확인해보자
먼저 변수를 복사할 때의 변화를 알아보자

```
	var a=10;
	var b=a;

	var obj1 ={c:10,d:'ddd'}
	var obj2 = obj1;
```

변수영역
| 주소 |...1002| 1003 |1004|1005...  
 | ---|----|---------|-------|---|
|데이터|이름: a, 값:@5002|이름: b, 값: @5002|이름: obj1, 값 : @5003|이름 obj2, 값 : @5003|

데이터 영역
| 주소 |...5002| 5003|5004|...
| ---|----|---------|-------|---|
|데이터| 10| @7102~?|'ddd'|

객체 @5003의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: x, 값: @5002|이름: d, 값: @5004|

기본형 데이터의 경우 1번째 줄 변수영역의 빈공간 @1002를 확보하고 식별자를 a로 지정한다. 숫자 10을 데이터 영역에서 검색하고 없으므로 빈 공간 @5002에 저장하고 주솟값을 @1002에 저장한다.
복사할 경우 변수 영역의 빈공간 @1003을 확보하고 식별자를 b로 지정하고 이제 식별자 a를 검색해 그 값을 찾아오는데 @1002에 저장된 값인 @5002를 가져온다.

5라인 부터 보자면 변수 영역의 빈공간 @1005을 확보하고 식별자를 obj2로 지정하고 이제 식별자 obj1를 검색해 그 값을 찾아오는데 @1004에 저장된 값인 @5003을 가져온다.

참조형 데이터가 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바로보게 되는 점에서 동일하다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기에 변수 복사 이후의 동작에도 큰차이가 발생한다.

변수 복사 이후 값 변경 결과 비교 -> 객체 프로퍼티 변경 시

```
	var a=10;
	var b=a;

	var obj1 ={c:10,d:'ddd'}
	var obj2 = obj1;

	b=15;
	obj2.c=20;
```

- 기본형
  데이터 영역에 15가 없으므로 새로운 공간에 15를 생성한다.
  그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾고 이름이 b인 변수영역의 값을 15의 주솟값을 변경한다.

- 참조형
  데이터 영역에 아직 20이 없으므로 새로운 공간에 저장하고 그 주소를 든 채로 변수 영역에서 obj2를 찾고 obj2의 값, 즉 객체의 주소로 이동하고 그곳에서 이름 c의 값을 20의 주솟값으로 변경한다.

이에 대한 결과를 그림으로 확인해보자
변수영역
| 주소 |...1002| 1003 |1004|1005...  
 | ---|----|---------|-------|---|
|데이터|이름: a, 값:@5002|이름: b, **값: @5005**|이름: obj1, 값 : @5003|이름 obj2, 값 : @5003|

데이터 영역
| 주소 |...5002| 5003|5004|5005|5006...
| ---|----|---------|-------|---|---|
|데이터| 10| @7102~?|'ddd'|**15**|**20**
객체 @5003의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: c, **값: @5006**|이름: d, 값: @5004|

변수영역부분에서 기본형에서 복사된 내용은 값이 서로 달라졌지만
참조형의 경우에는 값이 달라지지 않았다.
즉, 변수 a와 b는 서로 다른 주소를 바라보게 되었으나 obj1과 obj2는 같은 객체를 바라보고 있다.
그에 대한 이를 코드로 표현하면 이렇다

```
	a!==b
	obj1===obj2
```

이 결과가 바로 기본형과 참조형 데이터의 큰 차이점이다. 대부분의 자바스크립트 책에서 기본형은 값을 복사하고 참조형은 주솟값을 복사한다고 설명하지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해선느 주솟값을 복사해야하기에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없다.
다만, 기본형은 주솟값을 복사하는 과정이 한번만 이뤄지고 참조형은 한단계를 더 거치게 된다는 차이가 있다.

일반적으로는 기본형도 결국 주솟값을 참조한다는 사실을 소개하지 않는데, 그 이유는 이해하기에 다소 어려움이 있기 때문이라고 추측(?)한다. 그러나 이런 내부의 원리를 이해해야한다.
한 가지 더 짚고 넘어가자면 객체 자체가 변경된다면 어떻게 될지를 알아보자

```
	var a=10;
	var b=a;

	var obj1 ={c:10,d:'ddd'}
	var obj2 = obj1;

	b=15;
	obj2 = {c:20, d:'ddd'};
```

| 주소     | ...1002               | 1003                   | 1004                       | 1005                      | 1006 | 1007... |
| -------- | --------------------- | ---------------------- | -------------------------- | ------------------------- | ---- | ------- |
| 데이터   | **이름: a, 값:@5002** | **이름: b, 값: @5005** | **이름: obj1, 값 : @5003** | **이름 obj2, 값 : @5007** |
| **주소** | ...5002               | 5003                   | 5004                       | 5005                      | 5006 | 5007... |
| 데이터   | 10                    | @7102~?                | 'ddd'                      | 15                        | 20   | @8202~? |

객체 @5003의 변수 영역
| 주소 |...7102| 7103 |7104...  
 | ---|----|---------|-------|
|데이터|이름: c, 값: @5006|이름: d, 값: @5004|
객체 @5007의 변수 영역
| 주소 |...8102| 8103 |8104...  
 | ---|----|---------|-------|
|데이터|이름: c, 값: @5006|이름: d, 값: @5004|

모든 값이 달라지는 것을 확인할 수 있다.
즉, 참조형 데이터가 가변값이라고 설명할 때의 가변은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 불변 객체를 만드는 간단한 방법

불변 객체는 최근의 React, Vue, Angular등의 라이브러리나 프레임워크에서뿐만 아니라 함수형 프로그래밍, 디자인 패턴에서도 매우 중요한 기초이다.
바로 위에서 언급했듯이 참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티가 변경할 때만 성립한다.
데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.
그렇다면 **내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활요한다면 객체 역시 불변성을 확보할 수 있다.**

그러면 어떤 상황에서 불변 객체가 필요할까?
값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야하는 경우가 있을 때 불변객체가 필요하다.

객체의 가변성에 따른 문제점

```
	var user = {
		name: 'daepan',
		gender:'male',
	}//기존 user object

	var changeName = function(user, userName){
		var newUser = user;
		newUser.name = newName;
		return newUser;
	}//단순 객체 프로퍼티의 value만 변경하는 함수

	var user2 = changeName(user, 'Jung');//changeName함수 호출

	if(user !== user2){
		console.log('유저정보가 변경되었습니다.')
	}//위의 함수대로 변경된 이후 조건문이 성립하면서 출력되어야하지만 실제로는 그냥 통과된다.
```

왜 와이? 라는 생각을 가지고 console.log를 찍어보자

```
	console.log(user.name,user2.name);//Jung Jung
	console.log(user===user2);//true
```

이렇게 정보가 바뀐 시점에 알림을 보내야한다거나 바뀌기 전의 정보와 바뀐 후의 정보 차이를 가시적으로 보여주어야하는 등의 기능을 구현하기 위해서는 이대로 두어서는 안된다. 변경 전과 후에 서로 다른 객체를 바라보게 해야한다.

```
	var user = {
		name: 'daepan',
		gender:'male',
	}//기존 user object

	var changeName = function(user, userName){
		return{
			name : newName,
			gender : user.gender
		}
	}//새로운 객체 반환

	var user2 = changeName(user, 'Jung');//changeName함수 호출

	if(user !== user2){
		console.log('유저정보가 변경되었습니다.')//출력
	}
```

이런 식으로 새로운 객체로 선언하는 함수를 생성하면 아래와 같은 결과 값을 얻을 수 있다.

```
	console.log(user.name,user2.name);// daepan Jung
	console.log(user===user2);//false
```

객체의 프로퍼티의 갯수와 새로운 객체를 반환하는 copyObject 함수(얕은 복사)

```
	var copyObject=function(target){
		var result={};
		for(var prop in target){
			result[prop]=target[prop];
		}
		return result;
	}
```

이런 식으로 모든 개발자들이 user 객체 내부의 변경이 필요한 경우, 무조건 copyObject를 사용하기로 합의하고 규칙을 만들어 지킨다는 전제하에 user 객체가 곧 불변객체라고 볼 수 있다.
하지만 이러한 규칙을 따르지 않을 수도 있기에 불변성을 지키기 위해 시스템적으로 제약을 걸어 프로퍼티 변경을 할 수 없게 끔한다.
예를 들어 자바스크립트 내장 객체가 아닌 라이브러리 자체에서 불변성을 지닌 별도의 데이터 타입과 그에 따른 메서드를 제공한다. ex)immutable.js, baobab.js

## 얕은 복사와 깊은 복사

얕은 복사 : 바로 아래 단계의 값만 복사하는 방법
깊은 복사 : 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법
아래에 copyObject에 대해서 얕은 복사라는 설명을 적었는데 이 말은 **중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사**한다라는 것이다. <!--얕은 복사에서의 오류라는 것으로 설명된다
밑에 나오는 예제를 자세히 읽어봐야 안다.-->
해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 되며, 사본을 바꾸면 원본도 바뀌고 원본을 바꾸면 사본도 바뀌게 된다.  
그렇다면 중첩된 객체, 즉 참조형 데이터가 저장된 프로퍼티를 복사했을 때를 보자

```
	var user = {
		name: 'daepan',
		urls:{
			portfolio:'http://~~',
			blog:'http://velog.io~~',
			facebook:'http://facebook.~~',
			}
		}
		var user2 = copyObject(user);

		user2.name = 'Jung';
		console.log(user.name === user2.name);//false

		user2.urls.portfolio= 'http://$$$$';
		console.log(user.urls.portfolio === user2.urls.portfolio);//true

		user2.urls.blog= 'http://naverblog.';
		console.log(user2.urls.blog === user2.urls.blog);//true

```

이렇게 위와 같이 user2의 name 프로퍼티를 변경해도 user는 변경되지 않았지만
중첩된 객체 urls의 경우는 한쪽을 바꾸는 경우 다른 한쪽도 변한다는 것을 확인할 수 있다.
user에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어지는 반면에
urls의 내부 프로퍼티들은 기존 데이터를 그대로 참조하는 현상이 발생하기에
이에 대한 대처로 user.urls의 프로퍼티에 대해서도 불변객체로 만들어야 할 것이다.

```
		var user2 = copyObject(user);
		user2.urls = copyObject(user.urls);

		user2.urls.portfolio= 'http://$$$$';
		console.log(user.urls.portfolio === user2.urls.portfolio);//false

		user2.urls.blog= 'http://naverblog.';
		console.log(user2.urls.blog === user2.urls.blog);//false
```

어떤 객체를 복사할 떄 객체 내부의 모든 값을 복사해서 완저히 새로우 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 내부의 프로퍼티들을 복사해야한다. **이 과정을 참조형 데이터가 있을 때 마다 재귀적으로 수행해야만 비로소 깊은 복사가 되는 것이다!**

추가로 hasOwnProperty 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수 도 있다. ES5의 getter/setter를 복사하는 방법은 ES6의 Object.getOwnPropertyDescriptor 또는 ES2017의 Object.getOwnPropertyDescriptor 외의 마땅한 방법은 없다고 한다.

간단하게 깊은 복사를 처리할 수있는 다른 방법을 알아보자. 원리도 단순하다. 객체를 JSON 문법으로 표현된 문자열로 전화했다가 다시 JSON객체로 바꾸는 거다.
다만 메서드나 숨겨진 **proto**나 getter/setter등과 같은 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시한다.
httpRequest로 받은 데이터를 저장한 객체를 복사할 떄 등 순수한 정보만 다룰 때 활용하기 좋다고 한다.

```
	var copyObjectViaJSON= function(target){
		return JSON.parse(JSON.stringfy(target));
	}
```

<!--겁나게 익숙하네 저번에 종호형이 보내준 오마카세 페이지에서 봤다. 이렇게 쓰는 거구나... -->

## undefined와 null

자바스크립트에는 '없음'을 나타내는 값이 두 가지가 있다. 바로 undefined와 null이다. 두 값의 의미는 같은 것 같지만 미세하게 다르고, 사용하는 목적도 조금씩 다르다. 하나씩 알아보자

### undefined

사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동적으로 부여하는 경우가 있다.
자바스크립트가 자동적으로 부여하는 경우를 보자
자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않을 때 undefined를 반환한다. 그 경우는 세가지로 보는데

- 값을 대입하지 않은 변수
- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
- return 문이 없거나 호출되지 않는 함수의 실행결과

하지만 값을 대입하지 않는 경우에 대해 배열의 경우에는 조금 특이한 동작을 볼 수 있다.

```
	var arr1=[];
	arr1.length=3;
	console.log(arr1) empty x 3

	var arr2= new Array(3);
	console.log(arr2) // empty x 3

	var arr3 = [undefined, undefined, undefined]
	console.log(arr3)//undefined, undefined, undefined
```

이렇게 첫 번째 조건 처럼 값을 대입하지 않은 경우에 대한 출력이 다른 것을 확인할 수 있다.
이처럼 '비어있는 요소' 와 'undefined를 할당한 요소'는 출력 결과부터 다르다.
비어있는 요소는 순회와 관련된 많은 배열 메서드들의 순회대상에서 제외된다.
빈 요소와 배열 순회

```
	var arr1 = [undefined, 1];
	var arr2 = [];
	arr2[1]=1;

	arr1.forEach(function(v,i){console.log(v,i)});
	//undefined 0
	arr2.forEach(function(v,i){console.log(v,i)});
	// 1 1

	arr1.map(function(v,i){return v+i});//NaN, 2
	arr2.map(function(v,i){return v+i});
	//(2) [비어 있음, 2]
	arr1.filter(function(v){return !v;});
	//[undefined]
	arr2.filter(function(v){return !v;});
	//[]

	arr1.reduce(function(p,c,i){return p+c+i;},'');
	//'undefined011'
	arr2.reduce(function(p,c,i){return p+c+i;},'');
	//'11'
```

서로 다른 결과를 보여준다.
**사용자가 직접 undefined를 할당한 arr1에 대해서는 일반적으로 알고있는 대로 배열의 모든 요소를 순회해서 결과를 출력**한다.
그러나 arr2에 대한 결과를 보면, 각 메서드들이 비어 있는 요소에 대해서는 **어떠한 처리도 하지 않고 건너뛰었음**을 알 수 있다.

이러한 동작이 배열이여서 이런 행동을 보인 것이 아닌 배열또한 객체의 일종이기에 이런 현상이 나타난 것이다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하며, length 프로퍼티의 개수만큼 빈공간을 확보하고 각 공간에 인덱스를 이름으로 지정하는 것이 아닌, 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 한다.
이때의 프로퍼티나 배열의 요소는 고유의 프로퍼티 이름이 실존하게 되고, 순회대상이 될 수 있는 것이다.
**즉, 값이 지정되지 않은 인덱스는 '아직 존재하지 않는 프로퍼티' 라는 의미에 지나지 않는다.**

사용자가 직접 부여한 undefined는 그자체로 값이 된다.
비록 의미는 비어있지만 하나의 값으로 동작하기에 프로퍼티나 배열의 요소는 고유의 키값이 **실존하게 되고** 순회의 대상이 된다.
사용자가 직접 부여하지 않은 undefined, 즉, 자바스크립트 엔진이 반환하는 경우에는 해당 프로퍼티 내지 배열의 키값 자체가 **존재하지 않음**을 의미한다.

값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에는 자바스크립트가 직접 undefined를 할당한다. "var 변수는 LE가 활성화될 때 생성되면서 동시에 undefined로 초기화 한다'
한편 ES6에 등장한 let, const에 대해서 undefined를 할당하지 않고 초기화를 마치며, 이후 특정 값을 할당하기 전가지 해당 변수에 접근할 수 없다.
let, const는 LE가 활성화될 때 생성되지만 실제 변수가 평가되지 전까지는 접근할 수 없다.
(Lexical Enviroment : 자바스크립트 코드에서 변수나 함수 등의 식별자를 정의하는데 사용하는 객체)
moreInfo: [enter link description here](https://meetup.toast.com/posts/129)

같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야할 이유가 없다.
비어있음을 명시적으로 나태나고 싶을 때 nul을 대신 사용하면 된다.
undefined는 오직 '값을 대입하지 않는 변수에 접근하고자 할 떄 자바스크립트 엔진이 반환해주는 값으로서만 존재할 수 있다.'
