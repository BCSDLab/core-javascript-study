# 클로저

- 클로저의 의미 및 원리 이해
  클로저는 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다.
  자바스크립트 고유의 개념이 아니라서 ECMAScript명세에서도 클로저의 정의를 다루지 않고
  다양한 문헌에서 제각각의 정의로 클로저를 설명한다
  더구나 클로저를 설명하는 문장 자체도 이해하기 어려운 문장이 많다.

MDN에서는 클로저에 대해 클로저는 **함수와 그 함수가 선언될 당시는 lexical Enviroment의 상호관계에 따른 현상**
선언될 당시의 lexical enviroment는 실행컨텍스트의 구성요소 중 하나인 outerEnviromentReference에 해당한다.
LE의 enviromentRecord와 outerEnviromentReference에 의해 변수의 유효 범위인 스코프가 결정되고 스코프 체인이 가능해진다. 어떤 컨텍스트 A에서 선언한 내부함수 B의 실행 컨텍스트가 활성화된 시점에는 B의 outerEnviromentReference가 참조하는 대상인 A의 LexicalEnviroment에도 접근이 가능하다

A에서 B에서 선언한 변수를 접근할 수는 없지만 B에서 A에서 선언한 변수에 접근이 가능하다
여기서 combination의 의미를 알 수 있다
내부함수는 A의 Lexical Enviroment를 언제나 사용하는 것은 아니다. 내부 함수에서 외부 변수를 참조하지 않는 경우라는 combination이라고 하지 않고 내부함수에서 외부 변수를 참조하는 경우에 한해서만 combination. 즉 선언될 당시의 LexicalEnviroment와의 상호 관계가 의미가 있을 것이다.

**클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상**

클로저를 함수라고 표현하는 것은 다소 아쉬운 표현이다. 클로저란 하나의 현상을 의미한다.

## 클로저와 메모리 관리

클로저에 대해서 메모리 누수 위험에 대해서 클로저 사용을 조심해야한다거나 지양해야한다는 이론이 있다.
여기서 누수란?
개발자의 의도와 달리 어떤 값의 참조 카운트가 0이 되지 않아 GC의 수집대상이 되지 않음을 의미한다.
하지만 개발자의 의도적으로 참조카운트가 0이 되지 않도록 설계한 경우를 누수라고 표현하는 것은 적절치 않다.
이제는 의도대로 설계한 메모리 소모에 대한 관리법만 잘 파악해서 적용하는 것으로 충분하다
관리 방법은 클로저는 어떤 의도에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생한다.
그렇다면 그 필요성이 사라진 시점에는 더 메모리를 소모하지 않게 해주면 된다.
참조 카운트를 0으로 만들면 언젠가 GC가 수거해 갈 것이고 이때 소모됐던 메모리가 회수된다.
클로저에서 참조카운트를 0으로 만든 방법은 식별자에 참조형이 아닌 기본형 데이터를 할당하면 된다.
